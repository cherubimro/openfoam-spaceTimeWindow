/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | www.openfoam.com
     \\/     M anipulation  |
-------------------------------------------------------------------------------
    Copyright (C) 2024 OpenFOAM Foundation
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

Application
    spaceTimeWindowInitCase

Description
    Initialize a reconstruction case from spaceTimeWindowExtract output.

    Reads the extraction metadata and source case configuration to create
    a fully configured reconstruction case that can be run directly with
    the solver.

    Creates:
    - system/controlDict with matching time settings and solver
    - system/fvSchemes, fvSolution copied from source
    - constant/ files (turbulenceProperties, transportProperties, etc.)
    - Initial fields with spaceTimeWindow BC on oldInternalFaces

Usage
    spaceTimeWindowInitCase [OPTIONS]

    Options:
        -sourceCase <dir>   Source case directory (where extraction ran)
        -extractDir <dir>   Directory containing extracted data (default: current dir)
        -overwrite          Overwrite existing files

\*---------------------------------------------------------------------------*/

#include "argList.H"
#include "Time.H"
#include "fvMesh.H"
#include "IOdictionary.H"
#include "IFstream.H"
#include "OFstream.H"
#include "volFields.H"
#include "surfaceFields.H"
#include "OSspecific.H"
#include "foamVersion.H"
#include "Tuple2.H"
#include "DynamicList.H"
#include "SortableList.H"
#include <fstream>
#include <sstream>

using namespace Foam;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

void copyFile(const fileName& src, const fileName& dst)
{
    if (isFile(src))
    {
        cp(src, dst);
        Info<< "    Copied: " << src.name() << endl;
    }
    else
    {
        WarningInFunction
            << "Source file not found: " << src << endl;
    }
}

void copyDirectory(const fileName& src, const fileName& dst)
{
    if (isDir(src))
    {
        cp(src, dst);
        Info<< "    Copied directory: " << src.name() << endl;
    }
}

void writeControlDict
(
    const fileName& targetDir,
    const dictionary& metadata,
    const dictionary& sourceControlDict,
    const word& startTimeName,
    const word& endTimeName
)
{
    fileName controlDictPath = targetDir / "system" / "controlDict";
    mkDir(targetDir / "system");

    OFstream os(controlDictPath);

    // Write header
    os  << "FoamFile" << nl
        << "{" << nl
        << "    version     2.0;" << nl
        << "    format      ascii;" << nl
        << "    class       dictionary;" << nl
        << "    object      controlDict;" << nl
        << "}" << nl
        << "// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //" << nl
        << "// Generated by spaceTimeWindowInitCase" << nl
        << "// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //" << nl
        << nl;

    // Application - from metadata
    word solver = metadata.getOrDefault<word>("solver", "pimpleFoam");
    os.writeEntry("application", solver);
    os << nl;

    // Time settings from metadata
    scalar deltaT = metadata.get<scalar>("deltaT");
    bool adjustTimeStep = metadata.get<bool>("adjustTimeStep");
    label timePrecision = metadata.getOrDefault<label>("timePrecision", 8);

    // Write time values as strings to match directory names exactly
    os.writeEntry("startFrom", word("startTime"));
    os  << "startTime       " << startTimeName << ";" << nl;
    os << nl;

    // End time from boundaryData time range
    os.writeEntry("stopAt", word("endTime"));
    os  << "endTime         " << endTimeName << ";" << nl;
    os << nl;

    os.writeEntry("deltaT", deltaT);
    os << nl;

    // Write control
    os.writeEntry("writeControl", word("timeStep"));
    os.writeEntry("writeInterval", 100);
    os << nl;

    os.writeEntry("purgeWrite", 0);
    os << nl;

    os.writeEntry("writeFormat", word("ascii"));
    os.writeEntry("writePrecision", 8);
    os.writeEntry("writeCompression", word("off"));
    os << nl;

    os.writeEntry("timeFormat", word("fixed"));
    os.writeEntry("timePrecision", timePrecision);
    os << nl;

    os.writeEntry("runTimeModifiable", true);
    os << nl;

    os.writeEntry("adjustTimeStep", adjustTimeStep ? "yes" : "no");
    os << nl;

    // Copy maxCo and related settings if they exist
    if (sourceControlDict.found("maxCo"))
    {
        os.writeEntry("maxCo", sourceControlDict.get<scalar>("maxCo"));
    }
    if (sourceControlDict.found("maxDeltaT"))
    {
        os.writeEntry("maxDeltaT", sourceControlDict.get<scalar>("maxDeltaT"));
    }

    // Add libs entry for spaceTimeWindow
    os  << nl
        << "libs" << nl
        << "(" << nl
        << "    spaceTimeWindow" << nl
        << ");" << nl;

    Info<< "    Created: system/controlDict" << nl
        << "        solver = " << solver << nl
        << "        startTime = " << startTimeName << nl
        << "        endTime = " << endTimeName << nl
        << "        deltaT = " << deltaT << nl
        << "        timePrecision = " << timePrecision << nl
        << "        adjustTimeStep = " << (adjustTimeStep ? "yes" : "no") << endl;
}


void writeInitialField
(
    const fileName& targetDir,
    const word& fieldName,
    const word& fieldType,
    const dictionary& fieldDict,
    const word& timeName,
    const polyBoundaryMesh& bMesh
)
{
    fileName fieldPath = targetDir / timeName / fieldName;
    mkDir(targetDir / timeName);

    OFstream os(fieldPath);

    // Determine class name
    word className;
    if (fieldType == "scalar")
    {
        className = "volScalarField";
    }
    else if (fieldType == "vector")
    {
        className = "volVectorField";
    }
    else
    {
        className = "volScalarField";  // Default
    }

    // Write header
    os  << "FoamFile" << nl
        << "{" << nl
        << "    version     2.0;" << nl
        << "    format      ascii;" << nl
        << "    class       " << className << ";" << nl
        << "    object      " << fieldName << ";" << nl
        << "}" << nl
        << "// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //" << nl
        << nl;

    // Get dimensions from source field if available
    if (fieldDict.found("dimensions"))
    {
        os  << "dimensions      " << fieldDict.lookup("dimensions") << ";" << nl << nl;
    }
    else
    {
        // Default dimensions
        if (fieldName == "U")
        {
            os << "dimensions      [0 1 -1 0 0 0 0];" << nl << nl;
        }
        else if (fieldName == "p")
        {
            os << "dimensions      [0 2 -2 0 0 0 0];" << nl << nl;
        }
        else
        {
            os << "dimensions      [0 0 0 0 0 0 0];" << nl << nl;
        }
    }

    // Internal field - use source if available
    if (fieldDict.found("internalField"))
    {
        os  << "internalField   " << fieldDict.lookup("internalField") << ";" << nl << nl;
    }
    else
    {
        if (fieldType == "vector")
        {
            os << "internalField   uniform (0 0 0);" << nl << nl;
        }
        else
        {
            os << "internalField   uniform 0;" << nl << nl;
        }
    }

    // Boundary field
    os << "boundaryField" << nl << "{" << nl;

    // Get source boundary field if available
    const dictionary* bfDictPtr = fieldDict.findDict("boundaryField");

    forAll(bMesh, patchi)
    {
        const word& patchName = bMesh[patchi].name();

        os << "    " << patchName << nl
           << "    {" << nl;

        if (patchName == "oldInternalFaces")
        {
            // Use spaceTimeWindow BC
            os  << "        type            spaceTimeWindow;" << nl
                << "        dataDir         \"constant/boundaryData\";" << nl
                << "        fixesValue      true;" << nl;

            if (fieldType == "vector")
            {
                os << "        value           uniform (0 0 0);" << nl;
            }
            else
            {
                os << "        value           uniform 0;" << nl;
            }
        }
        else if (bfDictPtr && bfDictPtr->found(patchName))
        {
            // Copy from source
            const dictionary& patchDict = bfDictPtr->subDict(patchName);
            for (const entry& e : patchDict)
            {
                if (e.isStream())
                {
                    os << "        " << e.keyword() << "    " << e.stream() << ";" << nl;
                }
                else if (e.isDict())
                {
                    os << "        " << e.keyword() << nl;
                    e.dict().write(os, false);
                }
            }
        }
        else
        {
            // Default BC based on patch type
            const word& patchType = bMesh[patchi].type();
            if (patchType == "wall")
            {
                if (fieldName == "U")
                {
                    os  << "        type            noSlip;" << nl;
                }
                else if (fieldName == "p")
                {
                    os  << "        type            zeroGradient;" << nl;
                }
                else if (fieldName == "nut" || fieldName == "nuTilda")
                {
                    os  << "        type            nutWallFunction;" << nl
                        << "        value           uniform 0;" << nl;
                }
                else if (fieldName == "k")
                {
                    os  << "        type            kqRWallFunction;" << nl
                        << "        value           uniform 0;" << nl;
                }
                else if (fieldName == "epsilon")
                {
                    os  << "        type            epsilonWallFunction;" << nl
                        << "        value           uniform 0;" << nl;
                }
                else if (fieldName == "omega")
                {
                    os  << "        type            omegaWallFunction;" << nl
                        << "        value           uniform 0;" << nl;
                }
                else
                {
                    os  << "        type            zeroGradient;" << nl;
                }
            }
            else if (patchType == "empty")
            {
                os  << "        type            empty;" << nl;
            }
            else if (patchType == "symmetry" || patchType == "symmetryPlane")
            {
                os  << "        type            symmetry;" << nl;
            }
            else
            {
                os  << "        type            zeroGradient;" << nl;
            }
        }

        os << "    }" << nl;
    }

    os << "}" << nl;
    os << nl << "// ************************************************************************* //" << nl;

    Info<< "    Created: " << timeName << "/" << fieldName << endl;
}


int main(int argc, char *argv[])
{
    argList::addNote
    (
        "Initialize a reconstruction case from spaceTimeWindowExtract output"
    );

    argList::addOption
    (
        "sourceCase",
        "dir",
        "Source case directory (where extraction ran)"
    );

    argList::addOption
    (
        "extractDir",
        "dir",
        "Directory containing extracted data (default: current dir)"
    );

    argList::addBoolOption
    (
        "overwrite",
        "Overwrite existing files"
    );

    argList::noParallel();
    argList::noFunctionObjects();

    #include "setRootCase.H"

    // Get arguments
    fileName sourceCase;
    if (!args.readIfPresent("sourceCase", sourceCase))
    {
        FatalErrorInFunction
            << "Must specify -sourceCase <dir>" << nl
            << exit(FatalError);
    }

    fileName extractDir = args.getOrDefault<fileName>("extractDir", args.path());
    bool overwrite = args.found("overwrite");

    Info<< "spaceTimeWindowInitCase" << nl
        << "    Source case:    " << sourceCase << nl
        << "    Extract dir:    " << extractDir << nl
        << endl;

    // Verify source case exists
    if (!isDir(sourceCase))
    {
        FatalErrorInFunction
            << "Source case directory not found: " << sourceCase << nl
            << exit(FatalError);
    }

    // Find and read extraction metadata
    // Look for oldInternalFaces in boundaryData
    fileName boundaryDataDir = extractDir / "constant" / "boundaryData";
    fileNameList patches = readDir(boundaryDataDir, fileName::DIRECTORY);

    fileName metadataPath;
    word oldInternalPatchName;

    for (const fileName& patchDir : patches)
    {
        fileName testPath = boundaryDataDir / patchDir / "extractionMetadata";
        if (isFile(testPath))
        {
            metadataPath = testPath;
            oldInternalPatchName = patchDir;
            break;
        }
    }

    if (metadataPath.empty())
    {
        FatalErrorInFunction
            << "No extractionMetadata found in " << boundaryDataDir << nl
            << "    Run spaceTimeWindowExtract first to create extraction data" << nl
            << exit(FatalError);
    }

    Info<< "Found extraction metadata: " << metadataPath << nl << endl;

    // Read metadata
    IFstream metaIs(metadataPath);
    dictionary metadata(metaIs);

    Info<< "Extraction metadata:" << nl
        << "    openfoamVersion = " << metadata.getOrDefault<word>("openfoamVersion", "unknown") << nl
        << "    solver = " << metadata.getOrDefault<word>("solver", "unknown") << nl
        << "    deltaT = " << metadata.get<scalar>("deltaT") << nl
        << "    adjustTimeStep = " << metadata.get<bool>("adjustTimeStep") << nl
        << "    extractionStartTime = " << metadata.get<scalar>("extractionStartTime") << nl
        << endl;

    // Read source controlDict
    fileName sourceControlDictPath = sourceCase / "system" / "controlDict";
    IFstream sourceControlDictIs(sourceControlDictPath);
    dictionary sourceControlDict(sourceControlDictIs);

    // Find available time directories in boundaryData (for endTime)
    fileName patchBoundaryDir = boundaryDataDir / oldInternalPatchName;
    fileNameList timeDirs = readDir(patchBoundaryDir, fileName::DIRECTORY);

    // Collect all valid time directories with their scalar values
    DynamicList<Tuple2<scalar, word>> timeList;

    for (const fileName& dir : timeDirs)
    {
        scalar t;
        if (readScalar(dir, t))
        {
            timeList.append(Tuple2<scalar, word>(t, dir));
        }
    }

    if (timeList.size() < 2)
    {
        FatalErrorInFunction
            << "Need at least 2 time directories in boundaryData, found "
            << timeList.size() << nl
            << "    The spaceTimeWindow BC requires data beyond the current time" << nl
            << exit(FatalError);
    }

    // Sort by time value
    Foam::sort(timeList, [](const Tuple2<scalar, word>& a, const Tuple2<scalar, word>& b)
    {
        return a.first() < b.first();
    });

    // First timestep (minimum)
    word minTimeName = timeList.first().second();
    scalar minTime = timeList.first().first();

    // Last timestep (maximum) - for information only
    word maxTimeName = timeList.last().second();

    // Second-to-last timestep - this is the usable endTime
    // because the BC needs to interpolate using data from the next timestep
    word endTimeName = timeList[timeList.size() - 2].second();

    Info<< "Boundary data time range: " << minTimeName << " to " << maxTimeName << nl
        << "    Usable endTime: " << endTimeName << " (last timestep data needed for interpolation)" << nl
        << endl;

    // Create target directories
    mkDir(extractDir / "system");
    mkDir(extractDir / "constant");

    // 1. Create controlDict
    Info<< "Creating system files..." << endl;
    writeControlDict(extractDir, metadata, sourceControlDict, minTimeName, endTimeName);

    // 2. Copy system files
    copyFile(sourceCase / "system" / "fvSchemes", extractDir / "system" / "fvSchemes");
    copyFile(sourceCase / "system" / "fvSolution", extractDir / "system" / "fvSolution");
    copyFile(sourceCase / "system" / "decomposeParDict", extractDir / "system" / "decomposeParDict");

    // 3. Copy constant files (mandatory for physical fidelity)
    Info<< nl << "Copying constant files (mandatory for fidelity)..." << endl;
    copyFile(sourceCase / "constant" / "turbulenceProperties", extractDir / "constant" / "turbulenceProperties");
    copyFile(sourceCase / "constant" / "transportProperties", extractDir / "constant" / "transportProperties");
    copyFile(sourceCase / "constant" / "momentumTransport", extractDir / "constant" / "momentumTransport");
    copyFile(sourceCase / "constant" / "thermophysicalProperties", extractDir / "constant" / "thermophysicalProperties");
    copyFile(sourceCase / "constant" / "g", extractDir / "constant" / "g");
    copyFile(sourceCase / "constant" / "RASProperties", extractDir / "constant" / "RASProperties");
    copyFile(sourceCase / "constant" / "LESProperties", extractDir / "constant" / "LESProperties");

    // 4. Read subset mesh to get boundary patches
    Info<< nl << "Reading subset mesh..." << endl;

    // Create a minimal Time object for the extract case
    Time runTime
    (
        Time::controlDictName,
        extractDir,
        ".",
        false,  // enableFunctionObjects
        false   // enableLibs
    );

    // Read the mesh
    fvMesh mesh
    (
        IOobject
        (
            fvMesh::defaultRegion,
            runTime.constant(),
            runTime,
            IOobject::MUST_READ
        )
    );

    const polyBoundaryMesh& bMesh = mesh.boundaryMesh();

    Info<< "Subset mesh patches:" << endl;
    forAll(bMesh, patchi)
    {
        Info<< "    " << bMesh[patchi].name()
            << " (" << bMesh[patchi].type() << "): "
            << bMesh[patchi].size() << " faces" << endl;
    }

    // 5. Find extracted fields from boundaryData
    fileNameList firstTimeFiles;
    for (const fileName& dir : timeDirs)
    {
        scalar t;
        if (readScalar(dir, t) && mag(t - minTime) < SMALL)
        {
            firstTimeFiles = readDir(patchBoundaryDir / dir, fileName::FILE);
            break;
        }
    }

    wordList extractedFields;
    for (const fileName& f : firstTimeFiles)
    {
        if (f != "points" && f != "extractionMetadata")
        {
            extractedFields.append(f);
        }
    }

    Info<< nl << "Extracted fields: " << extractedFields << endl;

    // 6. Update initial fields with spaceTimeWindow BC
    // The spaceTimeWindowExtract already wrote subset fields to extractDir
    // We just need to update the boundary conditions on oldInternalFaces
    Info<< nl << "Updating initial fields with spaceTimeWindow BC..." << endl;

    // Find the initial time directory in extract case (written by spaceTimeWindowExtract)
    fileNameList extractTimeDirs = readDir(extractDir, fileName::DIRECTORY);
    word initialTimeDir;

    for (const fileName& dir : extractTimeDirs)
    {
        scalar t;
        if (readScalar(dir, t))
        {
            initialTimeDir = dir;
            break;  // Use first time directory found
        }
    }

    if (initialTimeDir.empty())
    {
        FatalErrorInFunction
            << "No time directory found in extract directory: " << extractDir << nl
            << "    spaceTimeWindowExtract should have created initial fields" << nl
            << exit(FatalError);
    }

    Info<< "    Using initial time: " << initialTimeDir << endl;

    // Update each extracted field - modify oldInternalFaces BC to spaceTimeWindow
    // The extraction wrote fields with "calculated" BC on oldInternalFaces
    // We need to replace it with "spaceTimeWindow" BC
    for (const word& fieldName : extractedFields)
    {
        fileName fieldPath = extractDir / initialTimeDir / fieldName;

        if (!isFile(fieldPath))
        {
            WarningInFunction
                << "Field not found in extract directory: " << fieldPath << nl
                << "    Skipping..." << endl;
            continue;
        }

        // Read the entire file
        std::ifstream ifs(fieldPath.c_str());
        std::ostringstream buffer;
        buffer << ifs.rdbuf();
        std::string content = buffer.str();
        ifs.close();

        // Determine field type from class in header
        word fieldType = "scalar";
        if (content.find("volVectorField") != std::string::npos)
        {
            fieldType = "vector";
        }

        // Find and replace the oldInternalFaces BC
        // Pattern to find: oldInternalFaces { type calculated; ... }
        std::string searchStart = "oldInternalFaces";
        std::size_t pos = content.find(searchStart);

        if (pos != std::string::npos)
        {
            // Find the opening brace
            std::size_t braceStart = content.find('{', pos);
            if (braceStart != std::string::npos)
            {
                // Find the matching closing brace
                int braceCount = 1;
                std::size_t braceEnd = braceStart + 1;
                while (braceEnd < content.size() && braceCount > 0)
                {
                    if (content[braceEnd] == '{') braceCount++;
                    else if (content[braceEnd] == '}') braceCount--;
                    braceEnd++;
                }

                // Build the replacement BC
                std::string newBC;
                if (fieldType == "vector")
                {
                    newBC = "oldInternalFaces\n    {\n        type            spaceTimeWindow;\n        dataDir         \"constant/boundaryData\";\n        fixesValue      true;\n        value           uniform (0 0 0);\n    }";
                }
                else
                {
                    newBC = "oldInternalFaces\n    {\n        type            spaceTimeWindow;\n        dataDir         \"constant/boundaryData\";\n        fixesValue      true;\n        value           uniform 0;\n    }";
                }

                // Replace the old BC with the new one
                content = content.substr(0, pos) + newBC + content.substr(braceEnd);

                // Write back
                std::ofstream ofs(fieldPath.c_str());
                ofs << content;
                ofs.close();

                Info<< "    Updated: " << fieldName << " (oldInternalFaces -> spaceTimeWindow)" << endl;
            }
        }
    }

    // Also handle turbulence fields that exist in extract dir but weren't in extracted list
    // (e.g., if nut was extracted separately)
    wordList commonTurbFields = {"nut", "nuTilda", "k", "epsilon", "omega"};

    for (const word& fieldName : commonTurbFields)
    {
        if (!extractedFields.found(fieldName))
        {
            // Check if the field already exists in extract dir
            fileName fieldPath = extractDir / initialTimeDir / fieldName;
            if (isFile(fieldPath))
            {
                // Apply same BC update
                std::ifstream ifs(fieldPath.c_str());
                std::ostringstream buffer;
                buffer << ifs.rdbuf();
                std::string content = buffer.str();
                ifs.close();

                std::string searchStart = "oldInternalFaces";
                std::size_t pos = content.find(searchStart);

                if (pos != std::string::npos)
                {
                    std::size_t braceStart = content.find('{', pos);
                    if (braceStart != std::string::npos)
                    {
                        int braceCount = 1;
                        std::size_t braceEnd = braceStart + 1;
                        while (braceEnd < content.size() && braceCount > 0)
                        {
                            if (content[braceEnd] == '{') braceCount++;
                            else if (content[braceEnd] == '}') braceCount--;
                            braceEnd++;
                        }

                        std::string newBC = "oldInternalFaces\n    {\n        type            spaceTimeWindow;\n        dataDir         \"constant/boundaryData\";\n        fixesValue      true;\n        value           uniform 0;\n    }";
                        content = content.substr(0, pos) + newBC + content.substr(braceEnd);

                        std::ofstream ofs(fieldPath.c_str());
                        ofs << content;
                        ofs.close();

                        Info<< "    Updated: " << fieldName << " (oldInternalFaces -> spaceTimeWindow)" << endl;
                    }
                }
            }
        }
    }

    Info<< nl
        << "========================================" << nl
        << "Case initialization complete!" << nl
        << "========================================" << nl
        << nl
        << "Next steps:" << nl
        << "  1. (Optional) Adjust writeInterval in system/controlDict" << nl
        << "  2. Review boundary conditions in " << initialTimeDir << "/" << nl
        << "  3. Run the solver:" << nl
        << "     " << metadata.getOrDefault<word>("solver", "pimpleFoam") << nl
        << nl;

    Info<< "End" << nl << endl;

    return 0;
}


// ************************************************************************* //
